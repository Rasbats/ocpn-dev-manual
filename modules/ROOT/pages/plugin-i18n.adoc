= Internationalization (i18n)

[[i18n-overview]]
== Overview

The OpenCPN plugins shares the i18n infrastructure with the main
opencpn program. In particular, plugins are subprojects in the
main opencpn project at https://crowdin.net/[Crowdin].

The workflow is based on the gettext tools and the
https://crowdin.net/project/opencpn[Crowdin] translation web service.
In the end this converts all strings like `_(some string)` to translated
content in runtime, content which is taken from machine-dependent,
binary mo-files.

The workflow: image:i18n.png[]

* The source files' translatable strings are marked using the
  `_()`macro.
* Using the xgettext tool, the translatable strings are extracted
  to a pot file.
* The pot file is sent to Pavel, who submits it to the crowdin
  web translation service. Here, each plugin is a sub-project under
  the opencpn project.
* Translators translates the pot file to all sorts of languages using
  the https://crowdin.net/project/opencpn[Crowdin] web service.
* Plugin developers downloads the translated po-files, one for each
  language. 
* During the build process, each po-file is compiled to a mo-file.
  These are the files used in runtime to provide translations.

FIXME: Review, is this really how it works.

=== Concerning "Items" and "Texts", the rule is:

. Item in the language file 1 = Display text. +
Of course, this requires you to put more items in this file, but this is
the only way for each translator to take account of the peculiarities of
its language.
+
Currently, all the other plugins and the heart of OpenCPN follow this
rule and we can always translate very correctly. +

=== FAQ
* _I have a question about translation priority between core and plugins,
....How can this be dealt with?_*
+
It's simple. The language files of the plugins are loaded first. Then,
the core language file is loaded. the whole thing is a single language
file. If an item appears in a language file of a plugin and also,
strictly identical, in the file of the core, this constitutes a single
item. So the translation of the core takes the place of the translation
of the plugin.
+
The solution, to avoid translation conflicts, is that plugin developers
must ensure that the items they use are different from those of the
core.
+
It is not necessary that the difference be very great. Only one
different character is enough. +

* _How does ODraw ensure that it's translations are used?_*
+
ODraw uses a process to make sure its translations for are used for all
its items. It does not affect the mainline translations, just the
translation catalogue used by ODraw is its own. All plugins can use this
method without impacting any other. The one downside is that you need to
have translations for all words as the cascade back through the
different catalogues may not give you the answer you expect. This is
achieved by redefining the translation macro (done by cmake and
compiler) such that the source code looks the same, but the catalogue
being used is different.
+
This process is currently used in the *ODraw* and *Watchdog* plugins. It
is a simple change to a couple of files to implement.

* _For Compiling, what is the Process to update Internationalization
files when compiling plugins?_*
+
The "normal" routine is that when new development for each plugin is
ready, at least for text parts, address a message to Pavel or me and we
can upload the new strings, the POT-file, to Crowdin. When translators
are ready or at least to an acceptable level and before release a new
message will result in download of translations, the po-files, and a PR
to the plugin's Github. The crucial task is to message when new strings
are ready for Crowdin. "As simple as that".
